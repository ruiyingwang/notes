
* 常见关键词
JWT, SSO, session, OAuth2.0, token, cookie, 证书

* 目前猜测：证书与账号密码一样是一种登陆凭证，类似的还有ssh的pom文件，私钥文件等，用于证明身份以此进入授权

* cookie是浏览器提供的一种客户端存储方式, http协议的某些header是可以直接控制cookie的，除此以外的客户端存储方式还有localStoragee等?
* cookie是默认只能支持当前层级域名的，不止此跨域及其一级域名，最多可以通过设置使其支持一级域名。

* session是存储于服务器端的一个存有与客户端通信上下文的对象，该对象可以用于记录客户端的登陆状态，一般存储与服务器端(也可以存储于客户端每次发送请求时携带，但是会导致性能问题)，客户端通过sessionID以让客户端知晓使用哪个session.
以上仅限于单体应用，在微服务架构中会存在多个服务端，且其内存不共享(虽然通过数据库可以共享, 或者使用common session), 因此无法像单体应用一样确保使用的服务端具有该session，也即是"无状态".
* 作为"无状态"服务端(Restful API)的解决方案, 使用token来替代session控制授权, JWT与OAuthe2.0均基于token进行验证

* JWT: Json Web Token
* 


* ？无论是token还是session就一定安全吗？不可以被暴力破解吗？
* 字符串密码也是同理，即便进行了加密处理，依旧可以是暴力枚举出来的



* 关于编码方式
base64: 


* 关于加密方式
    * 对称加密: 
        * 加密工作由(密钥+加密算法)完成，但密钥只有一个 - 密文与明文几乎等长, 速度快，但易导致密钥膨胀 - 常见对称加密算法: DES, AES, PBE, RC5, BLOWFISH
    * 非对称加密: 
        * 加密工作由(密钥+加密算法)完成，但密钥分为(公钥, 私钥) - 密文与明文几乎等长, 效率比对称加密低非常多 - 常见非对称加密算法: RSA, DSA, ECC, DH, Elgamal, AdiShamir, Miller Rabin, Merkle-Hellman
        * 在传输数据的场景中，接收方公布公钥，发送方使用公钥加密信息，接收方接收后使用私钥进行解密(我收的时候，只有我有私钥，只有我看得懂(只有我看得懂，所以秘闻随便公布))
        * 在数字签名的场景中，发送方公布公钥，发送方使用私钥机密信息，接收方接受后使用公钥解密信息(我发的时候，只有我有私钥，一定是我发的(只有我签的了字，所以信息来源一定是我))
* 摘要算法
    * 将信息散列成固定长度的密文信息，也称哈希算法，散列算法 - 散列算法有微乎其微的可能性出现相同的情况 - 常见散列算法: MD5 SHA HMAC CRC
    * 确保下载文件的完整性， 接口交互数据的完整性， 数字签名的指纹生成算法
* 数字签名与数字证书
    * 数字签名 是非对称加密的一种应用场景之一，但由于非对称加密的密文与明文长度相当，因此会对密文再使用摘要算法获取定长的 “数字签名”(指纹)？







#### Web的安全验证机制
* HTTP基本认证（HTTP Basic Auth）

#### Oauth2.0
* 第三方认证协议
* 分布式认证与授权


## Java安全框架: Spring Security

#### 基本概念
* 认证 -> 授权
* 会话: 用于记录用户的登陆状态: 如session, token
* 客户端存储token(JWT)的机制: Web的Cookie, localstorge, 移动端的内存
* RABC(role-based access control)

#### 基于session的认证方式

#### Spring Security 快速上手

#### Spring Security 实例(原理， springboot， 自定义)

#### 分布式认证方案

#### Oauth2.0